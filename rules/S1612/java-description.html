<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Method/constructor references are commonly agreed to be more readable than lambdas in most situations, and are therefore preferred.</p>
</div>
<div class="paragraph">
<p>However, method references are sometimes less concise than lambdas. In such cases, it might be fine to keep the lambda if it is better for readability. This choice is ultimately up to the programmer. Therefore, this rule only raises issues on lambda functions that could be replaced by shorter method references.</p>
</div>
<div class="paragraph">
<p><code>null</code> checks can be replaced with references to the <code>Objects::isNull</code> and <code>Objects::nonNull</code> methods, <code>casts</code> can be replaced with <code>SomeClass.class::cast</code> and <code>instanceof</code> can be replaced with <code>SomeClass.class::isInstance</code>.</p>
</div>
<div class="paragraph">
<p><strong>Note</strong> that this rule is automatically disabled when the project&#8217;s <code>sonar.java.source</code> is lower than <code>8</code>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class A {
  void process(List&lt;A&gt; list) {
    list.stream()
      .filter(a -&gt; a instanceof B)
      .map(a -&gt; (B) a)
      .map(b -&gt; b.&lt;String&gt;getObject())
      .forEach(b -&gt; { System.out.println(b); });
  }
}

class B extends A {
  &lt;T&gt; T getObject() {
    return null;
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class A {
  void process(List&lt;A&gt; list) {
    list.stream()
      .filter(B.class::isInstance)
      .map(B.class::cast)            // Note: keeping the lambda would also be compliant here, since it is shorter
      .map(B::&lt;String&gt;getObject)
      .forEach(System.out::println);
  }
}

class B extends A {
  &lt;T&gt; T getObject() {
    return null;
  }
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Replace this lambda with a method reference. [(sonar.java.source not set. Assuming 8 or greater.)]</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_is_duplicated_by_s2212">is duplicated by: <a data-rspec-id="S2212" class="rspec-auto-link">S2212</a></h3>

</div>
<div class="sect2">
<h3 id="_on_26_feb_2014_121941_freddy_mallet_wrote">on 26 Feb 2014, 12:19:41 Freddy Mallet wrote:</h3>
<div class="paragraph">
<p>Is implemented by http://jira.codehaus.org/browse/SONARJAVA-465</p>
</div>
</div>
</div>
</div>