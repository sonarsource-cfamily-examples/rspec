<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When constructing an object of a derived class, the sub-object of the base class is constructed first, and only then the constructor of the derived class is called. When there are multiple levels of inheritance, the process is the same, from the most base class to the most derived class. Along this construction process, the dynamic type of the object evolves and is the type of the sub-object under construction.</p>
</div>
<div class="paragraph">
<p>The destruction of the object follows the same process in reverse order.</p>
</div>
<div class="paragraph">
<p>As a consequence, when calling a virtual function from a constructor or a destructor, the actual function being called is not necessarily the version from the most-derived type, as some developers may believe, but the version that matches the level under construction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">struct A {
  virtual void f();
  virtual void g();
  virtual void h() = 0;
};

struct B : public A {
  B() {
    f();
    g();
  }
  void f() override;
};

struct C : public B {
  void f() override;
  void g() override;
  void h() override;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>When constructing an object of type C, the following occurs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The sub-object of type <code>A</code> is constructed.</p>
</li>
<li>
<p>The sub-object of type <code>B</code> is constructed.</p>
<div class="ulist">
<ul>
<li>
<p>The constructor <code>B::B()</code> is called, during this call, <code>*this</code> is considered as being of type <code>B</code>.</p>
</li>
<li>
<p>The function <code>B::f()</code> is called.</p>
</li>
<li>
<p>The function <code>A::g()</code> is called.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The object of type <code>C</code> is constructed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This surprising behavior can be even worse: If there is no implementation for a virtual function (in the example, if the constructor attempted to call <code>h()</code> which is still a pure virtual function) the behavior is undefined.</p>
</div>
<div class="paragraph">
<p>If you want to perform virtual calls during object construction that will consider the actual type of the object, the best way is probably to defer those calls right after the object is constructed, by using a factory function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">std::unique_ptr&lt;Base&gt; createObjectOfDerivedType(parameters) {
  auto result = ...;
  result-&gt;callVirtualFunction();
  return result;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This rule raises an issue when a non-final virtual function is called from a constructor or a destructor, therefore avoiding all surprising behavior.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Parent {
  public:
    Parent() {
      f1();
      f2(); // Noncompliant; confusing because Parent::f2() will always be called even if it is overridden
    }
    virtual ~Parent() {
      f3(); // Noncompliant; undefined behavior
    }

  private:
    int          f1();
    virtual void f2();
    virtual void f3() = 0; // pure virtual
};

class Child : public Parent {
  public:
    Child() { // leads to a call to Parent::f2(), not Child::f2()
      f3(); // Noncompliant; Child::f3() might be further overridden
    }
  protected:
    void f2() override;
    void f3() override;
};</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">class Parent {
  public:
    Parent() {
      f1();
      Parent::f2(); // acceptable but poor design
    }
    virtual ~Parent() {
      // call to pure virtual function removed
    }
  protected:
    void         f1();
    virtual void f2();
    virtual void f3() = 0;
};

class Child : public Parent {
  public:
    Child() {
    }
    virtual ~Child() {
      f3(); //  // Compliant - Well defined and predictable, a final function cannot be further overridden
    }
  protected:
    void f2() override;
    void f3() final;
};</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resources">Resources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/8zZGBQ">CERT, MET05-J.</a> - Ensure that constructors do not call overridable methods</p>
</li>
<li>
<p><a href="https://wiki.sei.cmu.edu/confluence/x/6ns-BQ">CERT, OOP50-CPP.</a> - Do not invoke virtual functions from constructors or destructors</p>
</li>
<li>
<p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-factory">C&#43;&#43; Core Guidelines C.50</a> - Use a factory function if you need “virtual behavior” during initialization</p>
</li>
</ul>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_implementation_specification">Implementation Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_message">Message</h3>
<div class="paragraph">
<p>Remove this call from a constructor to the overridable "XXXX" method.</p>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_on_15_mar_2016_114940_alban_auzeill_wrote">on 15 Mar 2016, 11:49:40 Alban Auzeill wrote:</h3>
<div class="paragraph">
<p>Add C&#43;&#43; Language-Specification</p>
</div>
</div>
</div>
</div>