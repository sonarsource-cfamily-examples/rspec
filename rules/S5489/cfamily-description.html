<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_why_is_this_an_issue">Why is this an issue?</h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>Mutexes</em> are synchronization primitives that allow to manage concurrency. It is a common situation to have to use multiple <em>mutexes</em> to protect multiple resources with different access patterns.</p>
</div>
<div class="paragraph">
<p>In such a situation, it is crucial to define an order on the set of all <em>mutexes</em>.</p>
</div>
<div class="paragraph">
<p>This order should be strictly followed when <em>locking</em> <em>mutexes</em>.</p>
</div>
<div class="paragraph">
<p>The reverse order should be strictly followed when <em>unlocking</em> <em>mutexes</em>.</p>
</div>
<div class="paragraph">
<p>Failure in doing so can lead to <em>deadlocks</em>.</p>
</div>
<div class="paragraph">
<p>In C&#43;&#43;, an easy way to make sure the unlocks are called in reverse order from the lock is to wrap the lock/unlock operations in a RAII class (since destructors of local variables are called in reverse order of their creation).</p>
</div>
<div class="paragraph">
<p>If instead of <code>pthread_mutex_t</code> you are using <code>std::mutex</code>, there are other mechanisms that allow you to avoid deadlocks in that case, see <a data-rspec-id="S5524" class="rspec-auto-link">S5524</a>.</p>
</div>
<div class="sect2">
<h3 id="_noncompliant_code_example">Noncompliant code example</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">pthread_mutex_t mtx1,mtx2;

void bad(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx1);
  pthread_mutex_unlock(&amp;mtx2);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_compliant_solution">Compliant solution</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-cpp" data-lang="cpp">pthread_mutex_t mtx1, mtx2; // if both have to be locked, mtx1 should always be locked before mtx2

void good(void)
{
  pthread_mutex_lock(&amp;mtx1);
  pthread_mutex_lock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx2);
  pthread_mutex_unlock(&amp;mtx1);
}</code></pre>
</div>
</div>
<hr>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_comments_and_links">Comments And Links</h2>
<div class="sectionbody">
<div class="paragraph">
<p>(visible only on this page)</p>
</div>
<div class="sect2">
<h3 id="_relates_to_s5486">relates to: <a data-rspec-id="S5486" class="rspec-auto-link">S5486</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5487">relates to: <a data-rspec-id="S5487" class="rspec-auto-link">S5487</a></h3>

</div>
<div class="sect2">
<h3 id="_relates_to_s5524">relates to: <a data-rspec-id="S5524" class="rspec-auto-link">S5524</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5486">is related to: <a data-rspec-id="S5486" class="rspec-auto-link">S5486</a></h3>

</div>
<div class="sect2">
<h3 id="_is_related_to_s5487">is related to: <a data-rspec-id="S5487" class="rspec-auto-link">S5487</a></h3>

</div>
<div class="sect2">
<h3 id="_on_6_nov_2019_235457_loïc_joly_wrote">on 6 Nov 2019, 23:54:57 Loïc Joly wrote:</h3>
<div class="paragraph">
<p>\[~geoffray.adde]</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Can you please review my changes?</p>
</li>
<li>
<p>It&#8217;s not clear to me if this rule is supposed to detect that in on place mtx1 is locked before mtx2, and in another place the order is reversed?</p>
</li>
</ul>
</div>
</div>
</div>
</div>